#!/bin/sh
# Copyright (C) 2002-2005 Flavio Stanchina
# Copyright (C) 2005-2006 Aric Cyr
# Copyright (C) 2007 Mario Limonciello
# Copyright (C) 2009 Alberto Milone

set -e

NAME=$1
VERSION=$2
TARBALL_ROOT=$3
ARCH=$4
UPGRADE=$5

if [ -z "$NAME" ] || [ -z "$VERSION" ]; then
    echo "Need NAME, and VERSION defined"
    echo "ARCH is optional"
    exit 1
fi

KERNELS=$(ls /lib/modules/)
CURRENT_KERNEL=$(uname -r)

#We never want to keep an older version side by side to prevent conflicts
if [ -e "/var/lib/dkms/$NAME/$VERSION" ]; then
    echo "Removing old $NAME-$VERSION DKMS files..."
    dkms remove -m $NAME -v $VERSION --all
fi

#Load new files, by source package and by tarball
echo "Loading new $NAME-$VERSION DKMS files..."
if [ -d "/usr/src/$NAME-$VERSION" ]; then
    dkms add -m $NAME -v $VERSION > /dev/null
fi

if [ -f "$TARBALL_ROOT/$NAME-$VERSION.dkms.tar.gz" ]; then
    if ! dkms ldtarball --archive "$TARBALL_ROOT/$NAME-$VERSION.dkms.tar.gz"; then
        echo ""
        echo ""
        echo "Unable to load DKMS tarball $TARBALL_ROOT/$NAME-$VERSION.dkms.tar.gz."
        echo "Common causes include: "
        echo " - You must be using DKMS 2.1.0.0 or later to support binaries only"
        echo "   distribution specific archives."
        echo " - Corrupt distribution specific archive"
        echo ""
        echo ""
        exit 2 
    fi
fi

# On 1st installation, let us look for a directory
# in /lib/modules which matches `uname -r`. If none
# is found it is possible that buildd is being used
# and that uname -r is giving us the name of the
# kernel used by the buildd machine.
# 
# If this is the case we try to build the kernel
# module for each kernel which has a directory in 
# /lib/modules. Furthermore we will have to tell 
# DKMS which architecture it should build the module
# for (e.g. if the buildd machine is using a
# 2.6.24-23-xen 64bit kernel).
#
# NOTE: if the headers are not installed then the
#       module won't be built, as usual
if [ -z "$UPGRADE" ]; then
    echo "First Installation: checking all kernels..."
    for KERNEL in $KERNELS; do
        if [ ${KERNEL} = ${CURRENT_KERNEL} ]; then
            # Kernel found
            KERNELS=$CURRENT_KERNEL
            break
        fi
    done
else
    KERNELS=$CURRENT_KERNEL
fi

if [ ! -z "$ARCH" ]; then
    echo "Building for architecture $ARCH"
    ARCH="-a $ARCH"
fi

for KERNEL in $KERNELS; do
    dkms_status=`dkms status -m $NAME -v $VERSION -k $KERNEL $ARCH`
    if [ `echo $KERNEL | grep -c "BOOT"` -gt 0 ]; then
        echo ""
        echo "Module build and install for $KERNEL was skipped as "
        echo "it is a BOOT variant"
        continue
    fi


    #if the module isn't yet built, try to build it
    if [ `echo $dkms_status | grep -c ": built"` -eq 0 ]; then
        if [ ! -L /var/lib/dkms/$NAME/$VERSION/source ]; then
            echo "This package appears to be a binaries-only package"
            echo " you will not be able to build against kernel $KERNEL"
            echo " since the package source was not provided"
            continue
        fi
        if [ -e /lib/modules/$KERNEL/build/include ]; then
            echo "Building initial module for $KERNEL"
            dkms build -m $NAME -v $VERSION -k $KERNEL $ARCH > /dev/null
            echo "Done."
            dkms_status=`dkms status -m $NAME -v $VERSION -k $KERNEL $ARCH`
        else
            echo "Module build for the currently running kernel was skipped since the"
            echo "kernel source for this kernel does not seem to be installed."
        fi
    fi

    #if the module is built (either pre-built or just now), install it
    if [ `echo $dkms_status | grep -c ": built"` -eq 1 ] && 
       [ `echo $dkms_status | grep -c ": installed"` -eq 0 ]; then
        dkms install -m $NAME -v $VERSION -k $KERNEL $ARCH
    fi
done

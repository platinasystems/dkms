optimize with a single find call instead of multiple
loops with ls.
port to POSIX sh and drop the /bin/bash from the
shebang.
drop localization of the usage message - this is
inconsistent with all other init scripts on the system.
use case instead of grep for string matching
LP: #484386
--- a/dkms_autoinstaller
+++ b/dkms_autoinstaller
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 #
 # dkms_autoinstaller 		A service to automatically install DKMS modules
 # 				for new kernels.
@@ -25,24 +25,24 @@ fi
 
 test -f /usr/sbin/dkms || exit 0
 
-function invoke_command ()
+invoke_command ()
 {
     local exitval=0
     local exitval_file=`mktemp /tmp/dkms.XXXXXX`
-    [ -z "$verbose" ] && echo -en "$2..." >>$output_loc || echo -e "$1" >>$output_loc
-    if [ "$3" == background ] && [ -z "$verbose" ]; then
+    [ -z "$verbose" ] && echo -n "$2..." >>$output_loc || echo "$1" >>$output_loc
+    if [ "$3" = background ] && [ -z "$verbose" ]; then
 	(eval $1 >/dev/null 2>&1; echo "exitval=$?" >> "$exitval_file") &
 	while [ -e "$exitval_file" ] && ! [ -s "$exitval_file" ]; do
 	    sleep 3
-	    echo -en "." >>$output_loc
+	    echo -n "." >>$output_loc
 	done
 	. "$exitval_file"
     else
 	eval $1; exitval=$?
     fi
-    [ $exitval -gt 0 ] && echo -en "(bad exit status: $exitval)" >>$output_loc
+    [ $exitval -gt 0 ] && echo -n "(bad exit status: $exitval)" >>$output_loc
     rm -f "$exitval_file"
-    echo -en "\n" >>$output_loc
+    echo >>$output_loc
     return $exitval
 }
 
@@ -52,7 +52,7 @@ output_loc="/var/log/dkms_autoinstaller"
 [ -n "$2" ] && kernel=$2 && output_loc="/dev/stdout" || kernel=`uname -r`
 kernelver_rpm=`rpm -qf "/lib/modules/$kernel" 2>/dev/null | grep -v "not owned by any package" | grep kernel | head -1`
 if ! arch=`rpm -q --queryformat "%{ARCH}" "$kernelver_rpm" 2>/dev/null`; then
-    [ `uname -m` == "x86_64" ] && [ `cat /proc/cpuinfo | grep -c "Intel"` -gt 0 ] && [ `ls $install_tree/$kernel/build/configs 2>/dev/null | grep -c "ia32e"` -gt 0 ] && arch="ia32e" || arch=`uname -m`
+    [ `uname -m` = "x86_64" ] && [ `cat /proc/cpuinfo | grep -c "Intel"` -gt 0 ] && [ `ls $install_tree/$kernel/build/configs 2>/dev/null | grep -c "ia32e"` -gt 0 ] && arch="ia32e" || arch=`uname -m`
 fi
 kernel_preparation_done=""
 dkms_tree="/var/lib/dkms"
@@ -68,75 +68,64 @@ case "$1" in
 	fi
         echo "" >>$output_loc
 
-	for filename in `ls "$dkms_tree"`; do
-	    if [ -d "$dkms_tree/$filename" ] && ! [ -h "$dkms_tree/$filename" ]; then
-		modules_needing_status="$modules_needing_status $filename"
-	    fi
-	done
-
-        # Iterate over the modules
-	for module_in_tree in $modules_needing_status; do
-
-	    # Make sure its in the tree
-	    if [ -d "$dkms_tree/$module_in_tree" ]; then
-
-  	        # Determine which versions to show status for
+		# Determine which versions to show status for
 		do_autoinstall=""
 		version_count=0
 		already_installed=""
 		already_installed_version=""
-		for filename in `ls "$dkms_tree/$module_in_tree"`; do
-		    if [ -d "$dkms_tree/$module_in_tree/$filename" ] && ! [ -h "$dkms_tree/$module_in_tree/$filename" ] && [ "$filename" != "original_module" ]; then
+		for filename in $(find "$dkms_tree" -maxdepth 2 -mindepth 2 -type d -a -not -name original_module); do
 			version_count=$(($version_count + 1))
-			version_in_tree="$filename"
+			version_in_tree="$(basename $filename)"
 
-		        # Source in its dkms.conf to see if we should autoinstall
+			# Source in its dkms.conf to see if we should autoinstall
 			AUTOINSTALL=""
-			if [ -f $dkms_tree/$module_in_tree/$version_in_tree/source/dkms.conf ]; then
-				. $dkms_tree/$module_in_tree/$version_in_tree/source/dkms.conf
+			if [ -f $filename/source/dkms.conf ]; then
+				. $filename/source/dkms.conf
 			else
 				current_state="broken"
 				continue
 			fi
-			[ `echo "$AUTOINSTALL" | grep -ic "^y"` -gt 0 ] && do_autoinstall="yes"
+			case $AUTOINSTALL in
+				*y*)
+					do_autoinstall="yes"
+					;;
+			esac
 
 			# Get the current state
 			# a mod can be both built and installed-weak (stupid, but could be)
 			# but installed-weak comes last, so use tail
-			current_state=`dkms status -m $module_in_tree -v $version_in_tree -k $kernel -a $arch 2>/dev/null | awk {'print $5'} | tail -n 1`
-			[ "$current_state" == "installed" -o "$current_state" == "installed-weak" ] && already_installed="true" && already_installed_version=$version_in_tree
-		    fi
-		done
+			current_state=`dkms status -m $PACKAGE_NAME -v $version_in_tree -k $kernel -a $arch 2>/dev/null | awk {'print $5'} | tail -n 1`
+			[ "$current_state" = "installed" -o "$current_state" = "installed-weak" ] && already_installed="true" && already_installed_version=$version_in_tree
 
                 if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
-                    log_action_begin_msg " $module_in_tree ($version_in_tree)"
+                    log_action_begin_msg " $PACKAGE_NAME ($version_in_tree)"
                 fi                    
 
 		# Based on what we know, either do it or not
 		if [ "$current_state" = "broken" ]; then
-                    echo "$module_in_tree ($version_in_tree): Unable to locate $dkms_tree/$module_in_tree/$version_in_tree/source/dkms.conf" >>$output_loc
-                    echo -e "\tDKMS tree must be manually fixed." >>$output_loc
+                    echo "$PACKAGE_NAME ($version_in_tree): Unable to locate $dkms_tree/$module_in_tree/$version_in_tree/source/dkms.conf" >>$output_loc
+                    printf "\tDKMS tree must be manually fixed.\n" >>$output_loc
                     if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
                         log_action_end_msg 1
                     fi
                     continue
 		elif [ -n "$already_installed" ]; then
-		    echo "$module_in_tree ($already_installed_version): Already installed on this kernel." >>$output_loc
+		    echo "$PACKAGE_NAME ($already_installed_version): Already installed on this kernel." >>$output_loc
                     if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
                         log_action_end_msg 0
                     fi
 		elif [ -z "$do_autoinstall" ]; then
-		    echo "$module_in_tree ($version_in_tree): AUTOINSTALL not set in its dkms.conf." >>$output_loc
+		    echo "$PACKAGE_NAME ($version_in_tree): AUTOINSTALL not set in its dkms.conf." >>$output_loc
                     if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
                         log_action_end_msg 0
                     fi
 		elif [ -n "$do_autoinstall" ] && [ "$version_count" -gt 1 ]; then
-		    echo "$module_in_tree: Multiple versions in DKMS. Unsure what to do. Resolve manually." >>$output_loc
+		    echo "$PACKAGE_NAME: Multiple versions in DKMS. Unsure what to do. Resolve manually." >>$output_loc
                     if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
                         log_action_end_msg 1
                     fi
 		else
-		    echo "$module_in_tree ($version_in_tree): Installing module." >>$output_loc
+		    echo "$PACKAGE_NAME ($version_in_tree): Installing module." >>$output_loc
 		    if [ "$current_state" != "built" ] && ! [ -e /lib/modules/$kernel/build/include ]; then
 			echo "  Kernel headers for $kernel are not installed.  Cannot install this module." >>$output_loc
 			echo "  Try installing linux-headers-$kernel or equivalent." >>$output_loc
@@ -144,15 +133,15 @@ case "$1" in
 		    elif [ "$current_state" != "built" ] && [ -e /lib/modules/$kernel/build/include ]; then
 			return_status=""
 			if [ -z "$kernel_preparation_done" ]; then
-			    invoke_command "dkms build -m $module_in_tree -v $version_in_tree -k $kernel -a $arch -q --no-clean-kernel >>$output_loc" "." background
+			    invoke_command "dkms build -m $PACKAGE_NAME -v $version_in_tree -k $kernel -a $arch -q --no-clean-kernel >>$output_loc" "." background
 			    return_status="$?"
 			    kernel_preparation_done="true"
 			else
-			    invoke_command "dkms build -m $module_in_tree -v $version_in_tree -k $kernel -a $arch --no-prepare-kernel --no-clean-kernel -q >>$output_loc" "." background
+			    invoke_command "dkms build -m $PACKAGE_NAME -v $version_in_tree -k $kernel -a $arch --no-prepare-kernel --no-clean-kernel -q >>$output_loc" "." background
 			    return_status="$?"
 			fi
 			if [ "$return_status" -eq 0 ]; then
-			    invoke_command "dkms install -m $module_in_tree -v $version_in_tree -k $kernel -a $arch -q >>$output_loc" "." background
+			    invoke_command "dkms install -m $PACKAGE_NAME -v $version_in_tree -k $kernel -a $arch -q >>$output_loc" "." background
                             if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
                                 log_action_end_msg 0
                             else
@@ -167,7 +156,7 @@ case "$1" in
                             fi
 			fi
 		    else
-			invoke_command "dkms install -m $module_in_tree -v $version_in_tree -k $kernel -a $arch -q >>$output_loc" "." background
+			invoke_command "dkms install -m $PACKAGE_NAME -v $version_in_tree -k $kernel -a $arch -q >>$output_loc" "." background
 			return_status=$?
 			if [ "$return_status" -eq 101 ]; then
 			    echo "  A newer module version than this already exists in this kernel." >>$output_loc
@@ -176,8 +165,7 @@ case "$1" in
 			    echo "  Installation failed!" >>$output_loc
 			fi
 		    fi
-  		fi
-	    fi
+		fi
 	done
         if [ -z "$modules_needing_status" ]; then
             if [ ! -z "$DEBIAN_STYLE_LOGGING" ]; then
@@ -203,7 +191,7 @@ case "$1" in
 	exit 0
 	;;
   *)
-	echo $"Usage: $0 {start|stop}"
+	echo "Usage: $0 {start|stop}"
 esac
 
 exit 0
